package br.com.rcbs
import scala.collection.mutable.TreeSet
import scala.collection.mutable.ListBuffer
import java.io.PrintWriter

/ ** Assignment of Receivables
  *
  * Problem: Loss minimization
  *
  * This implementation provides support for minimizing financial losses
  * in transactions in which there is a need to negotiate installments to be assigned.
  *
  * Solution: Implementation of RMQ Algorithm
  *
  * In situations where there is a need to minimize a factor (eg loss) for
  * adjustment of the optimal solution the most efficient is a solution based on RMQ.
  * We opted for the Scala / Java solution for the ease of expressing ideas in a functional way
  * and the flexibility to create simple / complex types with mixed orientation (OO / Functional)
  * with readability.
  *
  * /
object Recebiveis extends App {
  val MIN_RCBV = 50
  val MAX_RCBV = 10000
  val TOT_RCB = 7e5  
  
  // Implicit Native Index Multilist
  implicit class IndexesList[A](list: ListBuffer[A]){
    def apply(indices: ListBuffer[Int]) = indices map list
  } 
  
  // Generate sub-lists from a list
  def subCombinationsSum[T](xs:ListBuffer[T]):Iterator[ListBuffer[T]] =
     xs.toSet.subsets.map(_.to[ListBuffer])
  
  // Portion of a receivable
  case class parcelas(var rcvb: BigDecimal,var parList:ListBuffer[BigDecimal],var perda:BigDecimal)
  val format = "Receb√≠vel , Parcelas, Valor_Perda"
  val result = StringBuilder.newBuilder
  var parcels = ListBuffer[parcelas]()
  
  // Rounds portions to more exact currency values
  def round(v: BigDecimal) = v.setScale(2,BigDecimal.RoundingMode.HALF_UP)
  
  // Always generate 12 plots
  def geraParcelas(v: BigDecimal) = {
      var list = ListBuffer[BigDecimal]()
      for(i<-12 to 1 by -1) list.append(round((BigDecimal.valueOf(i.toLong))/12)*v)     
      list      
  }

  // Generates receivables, installments, analyzes data generated by recording buffer
  // to save to csv file
  def processa() = {
    val aList: ListBuffer[Int] = (MIN_RCBV to MAX_RCBV).to[ListBuffer]
    val aListR: ListBuffer[Int] = aList(scala.util.Random.shuffle((0 until aList.length).to[ListBuffer]))   
    for(v <- aListR) {
      val parcelas = geraParcelas(BigDecimal.valueOf(v))
      val list = subCombinationsSum(parcelas).filter(list => list.sum==parcelas(0)).to[ListBuffer]       
      for(p <- list) {
        val sz = p.size
        val parVal = p.sum
        var perda = BigDecimal(0.0)
        sz match {
          case 1 => perda = parVal*0.001
          case 2 => perda = parVal*0.0008
          case 3 => perda = parVal*0.0006
          case 4 => perda = parVal*0.0004
          case 5 => perda = parVal*0.0003
          case 6 => perda = parVal*0.0002
          case _ => perda = parVal*0.0001
        }             
        parcels.append(new parcelas(BigDecimal(v),p,perda))        
      } 
      parcels = parcels.sortBy((_: parcelas).perda)
      for(s<-format) result.append(s);
      result.append("\n")
      result.append(parcels(0).rcvb+",")
      result.append(parcels(0).parList.mkString("|")+",")
      result.append(parcels(0).perda+"\n")
      parcels.remove(0)     
      while (!parcels.isEmpty) {
        val pr = parcels(0); parcels.remove(0)
        result.append(pr.rcvb+",")
        result.append(pr.parList.mkString("|")+",")
        result.append(pr.perda+"\n")        
      }
    }
  }
  val start = System.currentTimeMillis()
  processa()  
  new PrintWriter("Resultado_Perdas.csv") { write(result.toString); close }
  val end = System.currentTimeMillis()
  println("Running time =========> "+(end-start)/1000.0)
}
