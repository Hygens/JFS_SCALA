package br.com.rcbs
import scala.collection.mutable.TreeSet
import scala.collection.mutable.ListBuffer
import java.io.PrintWriter

 /** Assignment of Receivables
  *
  * Problem: Loss minimization
  *
  * This implementation provides support for minimizing financial losses
  * in transactions in which there is a need to negotiate installments to be assigned.
  *
  * Solution: Implementation of RMQ Algorithm
  *
  * In situations where there is a need to minimize a factor (eg loss) for
  * adjustment of the optimal solution the most efficient is a solution based on RMQ.
  * We opted for the Scala / Java solution for the ease of expressing ideas in a functional way
  * and the flexibility to create simple / complex types with mixed orientation (OO / Functional)
  * with readability.
  *
  */
object Recevables {
  val MIN_RCBV = 50
  val MAX_RCBV = 10000
  val TOT_RCB = 7e5  
  
  // Implicit Native Index Multilist
  implicit class IndexesList[A](list: ListBuffer[A]){
    def apply(indices: ListBuffer[Int]) = indices map list
  } 
  
  // Generate sub-lists from a list
  def subCombinationsSum[T](xs:ListBuffer[T]):Iterator[ListBuffer[T]] =
     xs.toSet.subsets.map(_.to[ListBuffer])
  
  // Portion of a receivable
  case class parcel(var rcvb: BigDecimal,var parList:ListBuffer[BigDecimal],var loss:BigDecimal)
  val format = "Receivable , Parcel(s), Loss_Value"
  val result = StringBuilder.newBuilder
  var parcelsList = ListBuffer[parcel]()
  
  // Rounds portions to more exact currency values
  def round(v: BigDecimal) = v.setScale(2,BigDecimal.RoundingMode.HALF_UP)
  
  // Always generate 12 plots
  def parcelsGenerator(v: BigDecimal) = {
      var list = ListBuffer[BigDecimal]()
      for(i<-12 to 1 by -1) list.append(round((BigDecimal.valueOf(i.toLong))/12)*v)     
      list      
  }

  // Generates receivables, installments, analyzes data generated by recording buffer
  // to save to csv file
  def process() = {
    val aList: ListBuffer[Int] = (MIN_RCBV to MAX_RCBV).to[ListBuffer]
    val aListR: ListBuffer[Int] = aList(scala.util.Random.shuffle((0 until aList.length).to[ListBuffer]))   
    for(v <- aListR) {
      val _parcels = parcelsGenerator(BigDecimal.valueOf(v))
      val list = subCombinationsSum(_parcels).filter(list => list.sum==_parcels(0)).to[ListBuffer]       
      for(p <- list) {
        val sz = p.size
        val parVal = p.sum
        var loss = BigDecimal(0.0)
        sz match {
          case 1 => loss = parVal*0.001
          case 2 => loss = parVal*0.0008
          case 3 => loss = parVal*0.0006
          case 4 => loss = parVal*0.0004
          case 5 => loss = parVal*0.0003
          case 6 => loss = parVal*0.0002
          case _ => loss = parVal*0.0001
        }             
        parcelsList.append(new parcel(BigDecimal(v),p,loss))        
      } 
      parcelsList = parcelsList.sortBy((_: parcel).loss)
      for(s<-format) result.append(s);
      result.append("\n")
      result.append(parcelsList(0).rcvb+",")
      result.append(parcelsList(0).parList.mkString("|")+",")
      result.append(parcelsList(0).loss+"\n")
      parcelsList.remove(0)     
      while (!parcelsList.isEmpty) {
        val pr = parcelsList(0); parcelsList.remove(0)
        result.append(pr.rcvb+",")
        result.append(pr.parList.mkString("|")+",")
        result.append(pr.loss+"\n")        
      }
    }
  }

  def main(args:Array[String]) = {
    val start = System.currentTimeMillis()
    process()  
    new PrintWriter("Loss_Result.csv") { write(result.toString); close }
    val end = System.currentTimeMillis()
    println("Running time =========> "+(end-start)/1000.0)
  }
}
